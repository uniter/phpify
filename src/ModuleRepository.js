/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    hasOwn = {}.hasOwnProperty;

/**
 * Contains a cache of configured PHP modules and the module factory fetcher
 * to use for both fetching any as-yet unloaded modules and determining their existence
 *
 * @param {Object} requireCache
 * @constructor
 */
function ModuleRepository(requireCache) {
    /**
     * @type {Object.<string, {id: string|number, factory: Function}>} PHP module factories, indexed by path
     */
    this.configuredModules = {};
    /**
     * @type {boolean} Indicates that a module's factory function should be returned without execution
     */
    this.loadingModuleFactoryOnly = false;
    /**
     * A special function, generated by the PHP module compiler,
     * that can be called to fetch the module wrapper of any compiled modules
     * or return true/false to determine whether they exist.
     * Note that this is set by the special Initialiser module
     * generated at compile-time (see Transformer)
     *
     * @type {Function|null}
     */
    this.moduleFactoryFetcher = null;
    /**
     * @type {Object} require.cache
     */
    this.requireCache = requireCache;
}

_.extend(ModuleRepository.prototype, {
    /**
     * Fetches the module wrapper factory function for a compiled PHP module,
     * if it exists in the compiled bundle
     *
     * @param {string} filePath
     * @returns {Function}
     * @throws {Error} Throws when the specified compiled module does not exist
     */
    getModuleFactory: function (filePath) {
        var cachePath,
            configuredModule,
            configuredModuleFactory,
            repository = this;

        if (hasOwn.call(repository.configuredModules, filePath)) {
            // Module has already been configured: return the cached module factory
            return repository.configuredModules[filePath].factory;
        }

        // Module has not yet been loaded: require it via the fetcher function. The transpiled module
        // will call back into the loader via `.load(...)` to configure it.
        // The `loadingModuleFactoryOnly` flag ensures that the module is not executed,
        // only its module factory is exported instead
        repository.loadingModuleFactoryOnly = true;
        configuredModuleFactory = repository.moduleFactoryFetcher(filePath, false);
        repository.loadingModuleFactoryOnly = false;

        if (configuredModuleFactory === null) {
            throw new Error('File "' + filePath + '" is not in the compiled PHP file map');
        }

        // By this point, the require()'d module should have called back via .prepare()
        // [via <Public API::Loader>.run()] and so its wrapper should be in the
        if (!hasOwn.call(repository.configuredModules, filePath)) {
            throw new Error('Unexpected state: module "' + filePath + '" should have been loaded by now');
        }
        if (repository.configuredModules[filePath].factory !== configuredModuleFactory) {
            throw new Error('Unexpected state: factory for module "' + filePath + '" loaded incorrectly');
        }

        cachePath = './' + filePath;
        configuredModule = repository.configuredModules[filePath];

        if (!hasOwn.call(repository.requireCache, configuredModule.id)) {
            throw new Error(
                'Expected path "' + cachePath + '" (id "' + configuredModule.id + '") to be in require.cache, ' +
                'but it was not'
            );
        }

        // Delete the module's exports object from the cache: it was not executed as we only wanted
        // to extract the factory function, so that will have been stored instead.
        // If the module's factory function is ever needed again, it will be fetched from the
        // .configuredModules[...] cache instead
        delete repository.requireCache[configuredModule.id];

        return repository.configuredModules[filePath].factory;
    },

    /**
     * Initializes the repository with a function
     * for fetching the compiled module wrappers of PHP modules
     *
     * @param {Function} phpModuleFactoryFetcher
     */
    init: function (phpModuleFactoryFetcher) {
        this.moduleFactoryFetcher = phpModuleFactoryFetcher;
    },

    /**
     * Configures the environment and path for the given module, and either executes it
     * and returns the result or just returns the module factory depending on mode.
     * Used by all compiled PHP modules
     *
     * @param {string} filePath
     * @param {string|number} moduleID
     * @param {Function} moduleFactory
     * @param {Environment} environment
     * @returns {Function}
     */
    load: function (filePath, moduleID, moduleFactory, environment) {
        var repository = this,
            configuredModuleFactory = moduleFactory.using({path: filePath}, environment);

        repository.configuredModules[filePath] = {
            id: moduleID,
            factory: configuredModuleFactory
        };

        if (repository.loadingModuleFactoryOnly) {
            // Only the factory is needed, don't execute
            return configuredModuleFactory;
        }

        // Create, execute and return the result of the module
        return configuredModuleFactory().execute();
    },

    /**
     * Determines whether the module with the given path exists in the bundle
     *
     * @param {string} filePath
     * @return {boolean}
     */
    moduleExists: function (filePath) {
        var repository = this;

        if (hasOwn.call(repository.configuredModules, filePath)) {
            // Module has already been configured: return the cached module factory
            return true;
        }

        // Module has not yet been loaded: determine its existence using the fetcher function.
        // To save space in the compiled bundle, the large switch statement with a case for each
        // compiled PHP module doubles as an existence-check (see Transformer for details)
        return repository.moduleFactoryFetcher(filePath, true);
    }
});

module.exports = ModuleRepository;
