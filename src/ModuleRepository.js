/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */

'use strict';

var _ = require('microdash'),
    hasOwn = {}.hasOwnProperty;

/**
 * Contains a cache of configured PHP modules and the module factory fetcher
 * to use for both fetching any as-yet unloaded modules and determining their existence
 *
 * @param {Object} requireCache
 * @constructor
 */
function ModuleRepository(requireCache) {
    /**
     * @type {Object.<string, {id: string|number, factory: Function}>} PHP module factories, indexed by path
     */
    this.configuredModules = {};
    /**
     * @type {boolean} Indicates that a module's factory function should be returned without execution.
     */
    this.loadingModuleFactoryOnly = false;
    /**
     * A special function, generated by the PHP module compiler,
     * that can be called to fetch the module wrapper of any compiled modules
     * or return true/false to determine whether they exist.
     * Note that this is set by the special Initialiser module
     * generated at compile-time (see Transformer)
     *
     * @type {Function|null}
     */
    this.moduleFactoryFetcher = null;
    /**
     * @type {Object} require.cache
     */
    this.requireCache = requireCache;
}

_.extend(ModuleRepository.prototype, {
    /**
     * Fetches the module wrapper factory function for a compiled PHP module,
     * if it exists in the compiled bundle
     *
     * @param {string} filePath
     * @returns {Function}
     * @throws {Error} Throws when the specified compiled module does not exist
     */
    getModuleFactory: function (filePath) {
        var configuredModuleFactory,
            repository = this;

        if (hasOwn.call(repository.configuredModules, filePath)) {
            // Module has already been configured: return the cached module factory
            return repository.configuredModules[filePath].factory;
        }

        // Module has not yet been loaded: require it via the fetcher function. The transpiled module
        // will call back into the loader via `.load(...)` to configure it.
        // The `loadingModuleFactoryOnly` flag ensures that the module is not executed,
        // only its module factory is exported instead
        repository.loadingModuleFactoryOnly = true;
        configuredModuleFactory = repository.moduleFactoryFetcher(filePath, false);
        repository.loadingModuleFactoryOnly = false;

        if (configuredModuleFactory === null) {
            throw new Error('File "' + filePath + '" is not in the compiled PHP file map');
        }

        // By this point, the require()'d module should have called back via .prepare()
        // [via <Public API::Loader>.run()] and so its wrapper should be in the map.
        if (!hasOwn.call(repository.configuredModules, filePath)) {
            throw new Error('Unexpected state: module "' + filePath + '" should have been loaded by now');
        }
        if (repository.configuredModules[filePath].factory !== configuredModuleFactory) {
            throw new Error('Unexpected state: factory for module "' + filePath + '" loaded incorrectly');
        }

        // Delete the module's exports object from the cache: it was not executed as we only wanted
        // to extract the factory function, so that will have been stored instead.
        // If the module's factory function is ever needed again, it will be fetched from the
        // .configuredModules[...] cache instead.
        repository.unrequire(filePath);

        return repository.configuredModules[filePath].factory;
    },

    /**
     * Initializes the repository with a function
     * for fetching the compiled module wrappers of PHP modules
     *
     * @param {Function} phpModuleFactoryFetcher
     */
    init: function (phpModuleFactoryFetcher) {
        this.moduleFactoryFetcher = phpModuleFactoryFetcher;
    },

    /**
     * Determines whether a module's factory function should be returned without execution.
     *
     * @returns {boolean}
     */
    isLoadingModuleFactoryOnly: function () {
        return this.loadingModuleFactoryOnly;
    },

    /**
     * Configures the path for the given module,
     * returning the configured module factory.
     *
     * @param {string} filePath
     * @param {string|number} moduleID
     * @param {Function} moduleFactory
     * @returns {Function}
     */
    load: function (filePath, moduleID, moduleFactory) {
        var repository = this,
            configuredModuleFactory = moduleFactory.using({path: filePath});

        repository.configuredModules[filePath] = {
            id: moduleID,
            factory: configuredModuleFactory
        };

        return configuredModuleFactory;
    },

    /**
     * Configures the path for the given bootstrap module,
     * returning a function that will remove the module from the require cache
     * so that it may separately be run as a standalone module if desired,
     * and also execute the configured module factory.
     *
     * @param {string} filePath
     * @param {string|number} moduleID
     * @param {Function} moduleFactory
     * @returns {Function}
     */
    loadBootstrap: function (filePath, moduleID, moduleFactory) {
        var repository = this,
            configuredModuleFactory = moduleFactory.using({path: filePath});

        repository.configuredModules[filePath] = {
            id: moduleID,
            factory: configuredModuleFactory
        };

        return function (environment) {
            // Remove the module from the require cache so that it may be run separately
            // as a standalone module if desired.
            repository.unrequire(filePath);

            return configuredModuleFactory({}, environment).execute();
        };
    },

    /**
     * Determines whether the module with the given path exists in the bundle
     *
     * @param {string} filePath
     * @return {boolean}
     */
    moduleExists: function (filePath) {
        var repository = this;

        if (hasOwn.call(repository.configuredModules, filePath)) {
            // Module has already been configured: return the cached module factory
            return true;
        }

        // Module has not yet been loaded: determine its existence using the fetcher function.
        // To save space in the compiled bundle, the large switch statement with a case for each
        // compiled PHP module doubles as an existence-check (see Transformer for details)
        return repository.moduleFactoryFetcher(filePath, true);
    },

    /**
     * Unloads a module from the require cache.
     *
     * @param {string} filePath
     */
    unrequire: function (filePath) {
        var cachePath,
            configuredModule,
            repository = this;

        if (!hasOwn.call(repository.configuredModules, filePath)) {
            throw new Error('Module "' + filePath + '" is not loaded');
        }

        cachePath = './' + filePath;
        configuredModule = repository.configuredModules[filePath];

        if (!hasOwn.call(repository.requireCache, configuredModule.id)) {
            throw new Error(
                'Path "' + cachePath + '" (id "' + configuredModule.id + '") is not in require.cache'
            );
        }

        delete repository.requireCache[configuredModule.id];
    }
});

module.exports = ModuleRepository;
